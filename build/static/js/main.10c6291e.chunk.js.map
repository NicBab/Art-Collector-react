{"version":3,"sources":["api/index.js","components/Feature.js","components/Loading.js","components/Preview.js","components/Search.js","components/Title.js","index.js"],"names":["BASE_URL","KEY","fetchQueryResultsFromTermAndValue","term","value","a","fetch","encodeURI","split","join","response","json","data","fetchQueryResultsFromURL","url","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Searchable","searchTerm","searchValue","setIsLoading","setSearchResults","handleClick","event","preventDefault","result","className","href","onClick","Feature","featuredResult","id","title","dated","images","primaryimageurl","description","culture","style","technique","medium","dimensions","people","division","department","contact","creditline","toLowerCase","map","person","index","key","displayname","length","image","src","baseimageurl","alt","Loading","Preview","setFeaturedResult","searchResults","info","fetchPage","pageUrl","results","console","error","disabled","prev","next","record","Search","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","useEffect","Promise","all","then","centuries","catch","onSubmit","htmlFor","type","placeholder","onChange","target","name","Title","App","isLoading","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.10c6291e.chunk.js","sourcesContent":["/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\n// import axios from 'axios';\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=16e4be84-9709-456d-a5f9-3407ed0cad34';\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}","import React, { Fragment } from \"react\";\n\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from \"../api\";\n\n/**\n * We need a new component called Searchable which:\n * Has a template like this:\n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n *\n * When someone clicks the anchor tag, you should:\n * - preventDefault on the event\n * - call setIsLoading, set it to true\n *\n * Then start a try/catch/finally block:\n *\n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch:\n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\nconst Searchable = ({\n  searchTerm,\n  searchValue,\n  setIsLoading,\n  setSearchResults,\n}) => {\n  const handleClick = async (event) => {\n    event.preventDefault();\n    setIsLoading(true);\n    try {\n      const result = await fetchQueryResultsFromTermAndValue(\n        searchTerm,\n        searchValue\n      );\n      return setSearchResults(result);\n    } catch (error) {\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <span className=\"content\">\n      <a href=\"#\" onClick={handleClick}>\n        {searchValue}\n      </a>\n    </span>\n  );\n};\n\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n *\n * <main id=\"feature\"></main>\n *\n * And like this when one is:\n *\n * <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n * </main>\n *\n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style,\n * technique, medium, dimensions, people, department, division, contact, creditline\n *\n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n *\n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n *\n * This component should be exported as default.\n */\nconst Feature = ({\n  featuredResult,\n  searchTerm,\n  searchValue,\n  setIsLoading,\n  setSearchResults,\n}) => {\n  if (!featuredResult) {\n    return <main id=\"feature\"></main>;\n  }\n  const {\n    title,\n    dated,\n    images,\n    primaryimageurl,\n    description,\n    culture,\n    style,\n    technique,\n    medium,\n    dimensions,\n    people,\n    department,\n    division,\n    contact,\n    creditline,\n  } = featuredResult;\n\n  return (\n    <main id=\"feature\">\n      <div className=\"object-feature\">\n        <header>\n          <h3>{title}</h3>\n          <h4>{dated}</h4>\n        </header>\n\n        <section className=\"facts\">\n          {culture ? (\n            <>\n              <span className=\"title\">Culture</span>\n              <Searchable\n                searchTerm=\"culture\"\n                searchValue={culture.toLowerCase()}\n                setIsLoading={setIsLoading}\n                setSearchResults={setSearchResults}\n              />\n            </>\n          ) : null}\n\n          {medium ? (\n            <>\n              <span className=\"title\">Medium</span>\n              <Searchable\n                searchTerm=\"medium\"\n                searchValue={medium.toLowerCase()}\n                setIsLoading={setIsLoading}\n                setSearchResults={setSearchResults}\n              />\n            </>\n          ) : null}\n\n          {technique ? (\n            <>\n              <span className=\"title\">Technique</span>\n              <Searchable\n                searchTerm=\"technique\"\n                searchValue={technique.toLowerCase()}\n                setIsLoading={setIsLoading}\n                setSearchResults={setSearchResults}\n              />\n            </>\n          ) : null}\n\n          {dimensions ? (\n            <>\n              <span className=\"title\">Dimensions</span>\n              <span className=\"content\">{dimensions}</span>\n            </>\n          ) : null}\n\n          {people\n            ? people.map(function (person, index) {\n                return (\n                  <Fragment key={`${index} + ${person.displayname}`}>\n                    <span className=\"title\">People</span>\n                    <Searchable\n                      searchTerm=\"person\"\n                      searchValue={person.displayname}\n                      setIsLoading={setIsLoading}\n                      setSearchResults={setSearchResults}\n                    />\n                  </Fragment>\n                );\n              })\n            : null}\n    \n          {division ? (\n            <>\n              <span className=\"title\">Division</span>\n              <span className=\"content\">{division}</span>\n            </>\n          ) : null}\n\n          {contact ? (\n            <>\n              <span className=\"title\">Contact</span>\n              <span className=\"content\">{contact}</span>\n            </>\n          ) : null}\n\n          {creditline ? (\n            <>\n              <span className=\"title\">Credit</span>\n              <span className=\"content\">{creditline}</span>\n            </>\n          ) : null}\n\n          {description ? (\n            <>\n              <span className=\"title\">Description</span>\n              <span className=\"content\">{description}</span>\n            </>\n          ) : null}\n\n          {style ? (\n            <>\n              <span className=\"title\">Style</span>\n              <span className=\"content\">{style}</span>\n            </>\n          ) : null}\n        </section>\n\n        <section className=\"photos\">\n          {/* <img src= IMAGE_URL alt= SOMETHING_WORTHWHILE /> */}\n          {images && images.length > 0 ? (\n            images.map((image) => {\n              return (\n                <img\n                  src={image.baseimageurl}\n                  alt={image.baseimageurl}\n                  key={image.baseimageurl}\n                />\n              );\n            })\n          ) : primaryimageurl ? (\n            <img src={primaryimageurl} alt={primaryimageurl} />\n          ) : null}\n        </section>\n      </div>\n    </main>\n  );\n};\n\nexport default Feature;\n","import React from 'react';\n\nconst Loading = () => {\n    return (\n        <div id=\"loading\">\n            <h2 className=\"message\">Searching...</h2>\n        </div>\n    )\n    \n}\n\nexport default Loading;\n\n\n/**\n * Create and export a component called Loading which uses this static HTML template:\n * \n * <div id=\"loading\">\n *   <h2 className=\"message\">Searching...</h2>\n * </div>\n */\n","import React from 'react';\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from '../api';\n\n\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\nconst Preview = ({\n  setSearchResults,\n  setFeaturedResult,\n  setIsLoading,\n  searchResults: {info, records},\n}) => {\n\n  /**\n   * Don't touch this function, it's good to go.\n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return <aside id=\"preview\">\n    <header className=\"pagination\">\n      {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n      <button \n        disabled={info.prev ? false : true} \n        className=\"previous\"\n        onClick={() => {fetchPage(info.prev)}}> Previous </button>\n      {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n      <button\n        disabled={info.next ? false : true}\n        className=\"next\"\n        onClick={() => {fetchPage(info.next)}}> Next </button>\n    </header>\n\n    <section className=\"results\">\n      {records.map((record, index) => {\n        return (\n         <div\n          key={index}\n          className=\"object-preview\"\n          onClick={(event) => {\n            event.preventDefault();\n            setFeaturedResult(record);\n            // set the featured result to be this record, using setFeaturedResult\n          }}>\n            {record.primaryimageurl \n              ? ( <img src={record.primaryimageurl} alt={record.description} /> ) \n              : ( \"\" )}\n              { record.title ? <h3>{record.title}</h3> : <h3>MISSING INFO</h3> }\n        </div>\n      )})}\n    </section>\n  </aside>\n}\n\nexport default Preview;\n\n\n\n\n\n{\n  /* Here we should map over the records, and render something like this for each one:\n    <div  \n      key={ index }\n      className=\"object-preview\"\n      onClick={(event) => {\n        // prevent the default\n        // set the featured result to be this record, using setFeaturedResult\n      }}>\n\n      { \n        // if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing \n      }\n      {\n        // if the record.title exists, add this: <h3>{ record.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>\n      }\n    </div>\n  */\n}","import React, { useEffect, useState } from 'react';\n\n/**\n * Don't touch these imports!\n */\nimport { \n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults\n} from '../api';\n\n\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n   /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\n\nconst Search = ({\n  setIsLoading,\n  setSearchResults\n}) => {\n\nconst [centuryList, setCenturyList] = useState([]);\nconst [classificationList, setClassificationList] = useState ([]);\nconst [queryString, setQueryString] = useState ('');\nconst [century, setCentury] = useState ('any');\nconst [classification, setClassification] = useState ('any');\n \n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   * Make sure to console.error on caught errors from the API methods.\n   */\n  useEffect(() => {\n    Promise.all([\n      fetchAllCenturies(),\n      fetchAllClassifications(),\n    ])\n    .then(([centuries, classification]) => {\n      setCenturyList(centuries)\n      setClassificationList(classification)\n    })\n    .catch(console.error)\n  }, []);\n\n\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   * then, in a try/catch/finally block:\n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * - pass them to setSearchResults\n   * catch: error to console.error\n   * finally: call setIsLoading, set it to false\n   */\n  return <form id=\"search\" onSubmit={async (event) => {\n    event.preventDefault()\n    setIsLoading(true)\n\n    try {\n      const results = await fetchQueryResults({ century, classification, queryString })\n      setSearchResults(results)\n\n    } catch (error) {\n      console.error(error)\n    } finally {setIsLoading(false)\n  }}}>\n\n    <fieldset>\n     <label htmlFor=\"keywords\">Query</label>\n      <input \n        id=\"keywords\" \n        type=\"text\" \n        placeholder=\"enter keywords...\" \n        value={queryString} \n        onChange={(event) => {setQueryString(event.target.value)}}/>\n    </fieldset>\n\n\n    <fieldset>\n     <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({ classificationList.length })</span></label>\n      <select \n        name=\"classification\"\n        id=\"select-classification\"\n        value={classification} \n        onChange={(event) => {setClassification(event.target.value)}}>\n        <option value=\"any\">Any</option>\n\n        {/* map over the classificationList, return an <option /> */}\n          {classificationList.map((classification, index) => {\n            return (\n              <option value={ classification.name } key={`${index} ${classification.name}`}>\n                {classification.name}\n              </option>\n            )\n          })}\n\n      </select>\n    </fieldset>\n\n\n    <fieldset>\n     <label htmlFor=\"select-century\">Century <span className=\"century-count\">({ centuryList.length })</span></label>\n      <select \n        name=\"century\" \n        id=\"select-century\"\n        value={century} \n        onChange={(event) => {setCentury(event.target.value)}}>\n        <option value=\"any\">Any</option>\n\n        {/* map over the centuryList, return an <option /> */}\n        {centuryList.map((century, index) => {\n          return <option value={ century.name } key={`${index} ${century.name}`}>\n                 {century.name}\n                </option>\n        })}\n        \n      </select>\n     </fieldset>\n    <button>SEARCH</button>\n  </form>\n}\n\nexport default Search;","import React from 'react';\n\nconst Title = () => {\n    return (\n        <div id=\"title\">\n          <h1>\n            The Art Collector\n          </h1>\n          <h5>\n            Search the Harvard Art Museums' Private Collections\n          </h5>\n        </div>\n    );\n};\n\nexport default Title;\n\n\n/**\n * Create/export a component called Title which uses this static HTML as the template:\n * <div id=\"title\">\n *   <h1>\n *     The Art Collector\n *   </h1>\n *   <h5>\n *     Search the Harvard Art Museums' Private Collections\n *   </h5>\n * </div>\n */","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nimport {\n  Feature,\n  Loading,\n  Preview,\n  Search,\n  Title\n} from './components';\n\n\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\nconst App = () => {\n  const [searchResults, setSearchResults] = useState({info: {}, records: []} );\n  const [featuredResult, setFeaturedResult] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n   return <div className=\"app\">\n\n     {/* <Title /> is static, doesn't need any props */}\n     <Title />\n     \n     {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n     <Search \n      setSearchResults = {setSearchResults}\n      setIsLoading = {setIsLoading} />\n\n     {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n     <Preview \n      searchResults = {searchResults} \n      setSearchResults = {setSearchResults}\n      setIsLoading = {setIsLoading}\n      setFeaturedResult = {setFeaturedResult} /> \n\n     {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties)*/}\n     <Feature\n      featuredResult = {setFeaturedResult}\n      setIsLoading = {setIsLoading}\n      setSearchResults = {setSearchResults} /> \n\n     {/* <Loading /> is static, but should only render when isLoading is true */}\n     {/* use a ternary and render null if isLoading is false */}\n     {isLoading ? <Loading /> : null}\n   </div>\n }\n\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n)"],"sourceRoot":""}